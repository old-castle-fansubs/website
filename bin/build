#!/usr/bin/env python3
import json
import os
import typing as T
from datetime import datetime
from pathlib import Path

import PIL.Image
import dateutil.parser
import jinja2


ROOT_DIR = Path(__file__).parent.parent
TARGET_DIR = Path('public')


class AnimeLoader(jinja2.BaseLoader):
    source = ''

    def get_source(
            self,
            environment: jinja2.Environment,
            template: str
    ) -> T.Any:
        if template != 'generated_anime.html':
            raise jinja2.TemplateNotFound(template)
        return (AnimeLoader.source, None, lambda: False)


class FeaturedImage:
    def __init__(self, date: datetime, name: str) -> None:
        self.date = date
        self.name = name

    @property
    def url(self) -> str:
        return 'img/featured/' + self.name

    @property
    def thumbnail_url(self) -> str:
        return 'img-thumb/featured/' + self.name

    @property
    def path(self) -> Path:
        return ROOT_DIR / self.url

    @property
    def thumbnail_path(self) -> Path:
        return TARGET_DIR / self.thumbnail_url


class Release:
    def __init__(
            self,
            date: datetime,
            file_name: str,
            file_version: int,
            episode_number: str,
            episode_title: str,
            links: T.List[str],
            is_visible: bool
    ) -> None:
        self.date = date
        self.file_name = file_name
        self.file_version = file_version
        self.episode_number = episode_number
        self.episode_title = episode_title
        self.links = links
        self.is_visible = is_visible

    @property
    def is_hidden(self) -> bool:
        return not self.is_visible


class Anime:
    def __init__(
            self,
            title: str,
            content: str,
            stem: str,
            is_finished: bool
    ) -> None:
        self.title = title
        self.content = content
        self.stem = stem
        self.is_finished = is_finished

    @property
    def url(self):
        return 'anime-' + self.stem + '.html'


class News:
    def __init__(
            self,
            date: datetime,
            title: str,
            content: str,
            path: Path
    ) -> None:
        self.date = date
        self.title = title
        self.content = content
        self.path = path


def _save(path: Path, content: bytes) -> None:
    if path.exists():
        old_content = path.read_bytes()
        if old_content == content:
            return
    print('Writing', path)
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_bytes(content)


def _copy(source: T.Union[str, Path]) -> None:
    source_path = Path(source)
    if os.path.isdir(source_path):
        source_paths = [
            path
            for path in source_path.rglob('*')
            if path.is_file()
        ]
    else:
        source_paths = [source_path]
    for source_path in source_paths:
        target_path = TARGET_DIR / source_path
        _save(target_path, source_path.read_bytes())


def _get_news() -> T.Iterable[News]:
    news_dir = ROOT_DIR / 'html' / 'news'
    for news_path in news_dir.iterdir():
        with news_path.open('r', encoding='utf-8') as handle:
            date = dateutil.parser.parse(handle.readline().strip())
            title = handle.readline().strip()
            if handle.readline().strip():
                raise ValueError(
                    'Expected empty line in news ' + news_path.name
                )
            content = handle.read()
        yield News(date, title, content, news_path)


def _get_releases() -> T.Iterable[Release]:
    return [
        Release(
            date=dateutil.parser.parse(item['date']),
            file_name=item['file'],
            file_version=item['version'],
            episode_number=item['episode'],
            episode_title=item['title'],
            links=item['links'],
            is_visible='hidden' not in item or not item['hidden'],
        )
        for item in json.loads(
            (ROOT_DIR / 'data' / 'releases.json').read_text(encoding='utf-8')
        )
    ]


def _get_featured_images() -> T.Iterable[FeaturedImage]:
    return [
        FeaturedImage(dateutil.parser.parse(item['date']), item['name'])
        for item in json.loads(
            (ROOT_DIR / 'data' / 'featured.json').read_text(encoding='utf-8')
        )
    ]


def _get_anime() -> T.Iterable[Anime]:
    anime_dir = ROOT_DIR / 'html' / 'anime'
    for anime_path in anime_dir.iterdir():
        with anime_path.open('r', encoding='utf-8') as handle:
            title = handle.readline().strip()
            status = handle.readline().strip()
            if status not in ('finished', 'ongoing'):
                raise ValueError(
                    f'Unknown status "{status}" in anime entry "{anime_path}"'
                )
            if handle.readline().strip():
                raise ValueError(
                    f'Expected empty line in anime entry "{anime_path}"'
                )
            content = handle.read()

        yield Anime(
            title=title,
            content=content,
            stem=anime_path.stem,
            is_finished=status == 'finished'
        )


def _render(
        env: jinja2.Environment,
        template: str,
        output: str,
        **kwargs: T.Any
) -> None:
    target_path = TARGET_DIR / output
    target_path.parent.mkdir(parents=True, exist_ok=True)
    new_content = env.get_template(template).render(**kwargs).encode('utf-8')
    _save(target_path, new_content)


def _render_home(env: jinja2.Environment) -> None:
    _render(
        env,
        template='home.html',
        output='index.html',
        featured_images=_get_featured_images()
    )


def _render_featured_images(env: jinja2.Environment) -> None:
    featured_images = _get_featured_images()

    for featured_image in featured_images:
        if featured_image.thumbnail_path.exists():
            continue
        image = PIL.Image.open(featured_image.path)
        image.thumbnail((320, 240))
        featured_image.thumbnail_path.parent.mkdir(exist_ok=True, parents=True)
        image.save(featured_image.thumbnail_path, 'JPEG')

    _render(
        env,
        template='featured-list.html',
        output='featured.html',
        featured_images=featured_images
    )


def _render_news(env: jinja2.Environment) -> None:
    _render(
        env,
        template='news.html',
        output='news.html',
        news_entries=sorted(
            _get_news(),
            key=lambda news: news.path,
            reverse=True
        )
    )


def _render_anime(env: jinja2.Environment) -> None:
    release_entries = list(_get_releases())
    anime_entries = list(sorted(_get_anime(), key=lambda anime: anime.title))

    for anime_entry in anime_entries:
        AnimeLoader.source = anime_entry.content
        _render(
            env,
            template='anime-page.html',
            output=anime_entry.url,
            anime_entry=anime_entry,
            releases=release_entries
        )

    _render(
        env,
        template='anime-list.html',
        output='anime.html',
        anime_entries=anime_entries
    )


def _render_releases(env: jinja2.Environment) -> None:
    _render(
        env,
        template='release-list.html',
        output='releases.html',
        releases=sorted(
            _get_releases(),
            key=lambda release: release.date,
            reverse=True
        )
    )


def _render_about(env: jinja2.Environment) -> None:
    _render(env, template='about.html', output='about.html')


def _render_guest_book(env: jinja2.Environment) -> None:
    _render(env, template='guest_book.html', output='guest_book.html')


def _render_attention(env: jinja2.Environment) -> None:
    _render(env, template='attention.html', output='attention.html')


def main() -> None:
    env = jinja2.Environment(loader=jinja2.ChoiceLoader([
        AnimeLoader(),
        jinja2.FileSystemLoader('html')
    ]))
    _render_home(env)
    _render_featured_images(env)
    _render_news(env)
    _render_anime(env)
    _render_releases(env)
    _render_about(env)
    _render_guest_book(env)
    _render_attention(env)
    _copy('data/style.css')
    _copy('data/comments.css')
    _copy('img')


if __name__ == '__main__':
    main()
