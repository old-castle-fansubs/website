#!/usr/bin/env python3
import argparse
import json
import re
from datetime import datetime
from pathlib import Path
from subprocess import PIPE, run

import pysubs2

import ass_tag_parser

ROOT_DIR = Path(__file__).parent.parent
RELEASES_JSON_PATH = ROOT_DIR / "data" / "releases.json"


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("path", type=Path)
    parser.add_argument("link", nargs="*")
    parser.add_argument("-d", "--dry-run", action="store_true")
    return parser.parse_args()


def extract_subtitles(source_path):
    out = run(["mkvmerge", "-i", source_path], stdout=PIPE).stdout.decode()
    results = re.search(r"Track ID (\d+): subtitles \(SubStationAlpha\)", out)
    if not results:
        raise RuntimeError("No subtiles found in the file")
    track_id = int(results.group(1))
    ass = run(
        [
            "mkvextract",
            "tracks",
            "-r",
            "/dev/null",
            source_path,
            f"{track_id}:/dev/stdout",
        ],
        stdout=PIPE,
    ).stdout
    return ass.decode()


def extract_text(ass_string):
    ret = ""
    for ass_item in ass_tag_parser.parse_ass(ass_string):
        if isinstance(ass_item, ass_tag_parser.AssText):
            ret += ass_item.text
    return ret.replace("\\N", "\n")


def get_version_from_file_name(file_name):
    return int(
        re.search(
            r"\[[0-9a-f]{4}([0-9a-f])[0-9a-f]{3}\]", file_name, re.I
        ).group(1)
    )


def get_episode_from_file_name(file_name):
    try:
        return re.search(r"([0-9]+) \[[0-9a-f]{8}\]", file_name, re.I).group(1)
    except AttributeError:
        return None


def get_title_from_subs(subs):
    titles = []

    for sub in subs:
        if sub.name == "[title]":
            clean_title = re.sub(
                r"[–—]?\s*episode\s+#?\d+\s*[–—:]?\s*",
                "",
                extract_text(sub.text),
                flags=re.I,
            )
            titles.append((extract_text(sub.text), clean_title))

    def sort(item):
        sub_text, clean_title = item
        return not re.search(r"\d|episode", sub_text, re.I)

    titles.sort(key=sort)

    if titles:
        return titles[0][1]
    return None


def main():
    args = parse_args()

    releases = json.loads(RELEASES_JSON_PATH.read_text())

    for path in (
        [args.path] if args.path.is_file() else sorted(args.path.iterdir())
    ):
        version = get_version_from_file_name(path.name)
        episode = get_episode_from_file_name(path.name)

        subs = pysubs2.SSAFile.from_string(extract_subtitles(path))
        title = get_title_from_subs(subs)

        release = {
            "date": f"{datetime.today():%Y-%m-%d %H:%M:%S}",
            "file": path.name,
            "version": version,
            "episode": episode,
            "title": title or "-",
            "links": args.link,
        }

        releases.append(release)
        if args.dry_run:
            print(json.dumps(release, indent=4))

    if not args.dry_run:
        RELEASES_JSON_PATH.write_text(json.dumps(releases, indent=4) + "\n")


if __name__ == "__main__":
    main()
