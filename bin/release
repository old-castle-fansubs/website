#!/usr/bin/env python3
import argparse
import json
import re
from datetime import datetime
from pathlib import Path
from subprocess import run, PIPE

import pysubs2

from ass_tag_parser import parse_ass


ROOT_DIR = Path(__file__).parent.parent
RELEASES_JSON_PATH = ROOT_DIR / 'releases.json'


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('path', type=Path)
    parser.add_argument('link', nargs='*')
    parser.add_argument('-d', '--dry-run', action='store_true')
    return parser.parse_args()


def extract_subtitles(source_path):
    out = run(['mkvmerge', '-i', source_path], stdout=PIPE).stdout.decode()
    results = re.search(r'Track ID (\d+): subtitles \(SubStationAlpha\)', out)
    if not results:
        raise RuntimeError('No subtiles found in the file')
    track_id = int(results.group(1))
    ass = run(
        [
            'mkvextract',
            'tracks',
            '-r',
            '/dev/null',
            source_path,
            f'{track_id}:/dev/stdout'
        ],
        stdout=PIPE).stdout
    return ass.decode()


def extract_text(ass_string):
    ret = ''
    for node in parse_ass(ass_string):
        if node['type'] == 'text':
            ret += node['text']
    return ret.replace('\\N', '\n')


def get_version_from_file_name(file_name):
    return int(
        re.search(
            r'\[[0-9a-f]{4}([0-9a-f])[0-9a-f]{3}\]',
            file_name,
            re.I)
        .group(1))


def get_episode_from_file_name(file_name):
    try:
        return (
            re.search(
                r'([0-9]+) \[[0-9a-f]{8}\]',
                file_name,
                re.I)
            .group(1))
    except AttributeError:
        return None


def get_title_from_subs(subs):
    titles = []

    for sub in subs:
        if sub.name == '[title]':
            clean_title = re.sub(
                r'[–—]?\s*episode\s+#?\d+\s*[–—:]?\s*',
                '',
                extract_text(sub.text),
                flags=re.I)
            titles.append((extract_text(sub.text), clean_title))

    def sort(item):
        sub_text, clean_title = item
        return not re.search(r'\d|episode', sub_text, re.I)

    titles.sort(key=sort)

    if titles:
        return titles[0][1]
    return None


def main():
    args = parse_args()

    subs = pysubs2.SSAFile.from_string(extract_subtitles(args.path))

    version = get_version_from_file_name(args.path.name)
    episode = get_episode_from_file_name(args.path.name)
    title = get_title_from_subs(subs)

    release = {
        'date': f'{datetime.today():%Y-%m-%d}',
        'file': args.path.name,
        'version': version,
        'episode': episode,
        'title': title or '-',
        'links': args.link,
    }

    if args.dry_run:
        print(json.dumps(release, indent=4))
    else:
        releases = json.loads(RELEASES_JSON_PATH.read_text())
        releases.append(release)
        RELEASES_JSON_PATH.write_text(json.dumps(releases, indent=4) + '\n')


if __name__ == '__main__':
    main()
